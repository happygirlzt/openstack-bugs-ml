{
    "status": "Fix Released", 
    "last_updated": "2010-10-25 20:28:52.927216+00:00", 
    "description": "Users can see things they shouldn't be able to.\n\nSTEPS:\n\n0) create two users a & b, NOT in the same project\n\n1) start an instance as user a\n\n2) get_console_output on user a's instance as user b\n\nEXPECTED:\n\n   the user should not get the output (user b should not be able to get console output for instances they don't own)\n\nACTUAL:\n\n   console output from instance is returned successfully\n\nDETAILS:\n\nfor instance, get_console_output in cloud.py:\n\n    def get_console_output(self, context, instance_id, **kwargs):\n        instance_ref = db.instance_get_by_str(context, instance_id[0])\n        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n                                   instance_ref['host']),\n                        {\"method\": \"get_console_output\",\n                         \"args\": {\"context\": None,\n                                  \"instance_id\": instance_ref['id']}})\n\nsends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n\nSimilarly for all other data store objects.\n\nPROPOSAL:\n\nMy thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.", 
    "tags": [], 
    "importance": "High", 
    "heat": 10, 
    "link": "https://bugs.launchpad.net/nova/+bug/644092", 
    "owner": "https://api.launchpad.net/1.0/~devcamcar", 
    "id": 644092, 
    "index": 299, 
    "openned": "2010-09-21 04:49:23.408996+00:00", 
    "created": "2010-09-21 04:49:23.408996+00:00", 
    "title": "authorization not checked in ec2 api", 
    "comments": [
        {
            "content": "Users can see things they shouldn't be able to.\n\nSTEPS:\n\n0) create two users a & b, NOT in the same project\n\n1) start an instance as user a\n\n2) get_console_output on user a's instance as user b\n\nEXPECTED:\n\n   the user should not get the output (user b should not be able to get console output for instances they don't own)\n\nACTUAL:\n\n   console output from instance is returned successfully\n\nDETAILS:\n\nfor instance, get_console_output in cloud.py:\n\n    def get_console_output(self, context, instance_id, **kwargs):\n        instance_ref = db.instance_get_by_str(context, instance_id[0])\n        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n                                   instance_ref['host']),\n                        {\"method\": \"get_console_output\",\n                         \"args\": {\"context\": None,\n                                  \"instance_id\": instance_ref['id']}})\n\nsends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n\nSimilarly for all other data store objects.\n\nPROPOSAL:\n\nMy thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.", 
            "date_created": "2010-09-21 04:49:23.408996+00:00", 
            "author": "https://api.launchpad.net/1.0/~anotherjesse"
        }, 
        {
            "content": "This also occurs in the rackspace API. \n\nGetting a common context and authorization would be nice.", 
            "date_created": "2010-09-21 04:51:39.038004+00:00", 
            "author": "https://api.launchpad.net/1.0/~anotherjesse"
        }, 
        {
            "content": "I think those rbac decorators all over the cloud API got me fooled into thinking this was taken care of.\n\nNow that I think about it, I'm not sure how they're supposed to work? They're applied before the object(s) being accessed are even known, so it only really checks if context.user has the given role on context.project, right? So any checks further down should check whether the object being accessed belongs to context.project. Is that accurate?", 
            "date_created": "2010-09-21 12:16:31.161315+00:00", 
            "author": "https://api.launchpad.net/1.0/~soren"
        }, 
        {
            "content": "On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n\n> Now that I think about it, I'm not sure how they're supposed to work?\n> They're applied before the object(s) being accessed are even known, so\n> it only really checks if context.user has the given role on\n> context.project, right? So any checks further down should check whether\n> the object being accessed belongs to context.project. Is that accurate?\n>\n\nYep, that's accurate.  The conversion from Tornado to eventlet (as of yet\nunmerged to trunk) moves all that into an \"Authorization\" middleware.  It\nmight help clarify the code if that were renamed to \"MethodAuthentication\"\nand we do data authentication somewhere else.\n\n\nConfidentiality Notice: This e-mail message (including any attached or\nembedded documents) is intended for the exclusive and confidential use of the\nindividual or entity to which this message is addressed, and unless otherwise\nexpressly indicated, is confidential and privileged information of Rackspace.\nAny dissemination, distribution or copying of the enclosed material is prohibited.\nIf you receive this transmission in error, please notify us immediately by e-mail\nat <email address hidden>, and delete the original message.\nYour cooperation is appreciated.\n\n", 
            "date_created": "2010-09-21 15:52:00+00:00", 
            "author": "https://api.launchpad.net/1.0/~gundlach"
        }, 
        {
            "content": "My thoughts on data authentication:\nFirst we turn context into a dictionary so it is easy to pass around everywhere.   The dictionary contains the following important data:\n{'request_id': <random req string>,\n 'user_id': ...,\n 'project_id': ...,\n 'superuser': <boolean, for bypassing project checking>\n 'deleted' <tristate yes, no, all>}\n\nsuperuser is set during authentication of the request, simply to avoid roundtrips to the auth layer. \n\nMy preference for a dictionary is simply that it is easy to pass through rabbit.\n\nthen inside the data layer, we have a simple check:\nif context['superuser']:\n  # don't limit the sql\nelif context['project_id']:\n  # add project_id = context\nelse:\n   raise\nswitch on deleted to add deleted=0, deleted=1 or ignore\n\nThe user_id and request_id aren't used in the datalayer but are in context to help with logging.\n\nOn Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n\n> On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n> \n>> Now that I think about it, I'm not sure how they're supposed to work?\n>> They're applied before the object(s) being accessed are even known, so\n>> it only really checks if context.user has the given role on\n>> context.project, right? So any checks further down should check whether\n>> the object being accessed belongs to context.project. Is that accurate?\n>> \n> \n> Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n> unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n> might help clarify the code if that were renamed to \"MethodAuthentication\"\n> and we do data authentication somewhere else.\n> \n> \n> Confidentiality Notice: This e-mail message (including any attached or\n> embedded documents) is intended for the exclusive and confidential use of the\n> individual or entity to which this message is addressed, and unless otherwise\n> expressly indicated, is confidential and privileged information of Rackspace.\n> Any dissemination, distribution or copying of the enclosed material is prohibited.\n> If you receive this transmission in error, please notify us immediately by e-mail\n> at <email address hidden>, and delete the original message.\n> Your cooperation is appreciated.\n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>   the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>   console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> \n> \n", 
            "date_created": "2010-09-21 18:18:30+00:00", 
            "author": "https://api.launchpad.net/1.0/~vishvananda"
        }, 
        {
            "content": "I like the practice of providing context all the way down the call stack.  However I think first class citizens should not be dictionaries.  We can accomplish the same thing with a proper object that implements todict()/fromdict().\n\nDevin\n\nOn Sep 21, 2010, at 11:18 AM, vishvananda wrote:\n\n> My thoughts on data authentication:\n> First we turn context into a dictionary so it is easy to pass around everywhere.   The dictionary contains the following important data:\n> {'request_id': <random req string>,\n> 'user_id': ...,\n> 'project_id': ...,\n> 'superuser': <boolean, for bypassing project checking>\n> 'deleted' <tristate yes, no, all>}\n> \n> superuser is set during authentication of the request, simply to avoid\n> roundtrips to the auth layer.\n> \n> My preference for a dictionary is simply that it is easy to pass through\n> rabbit.\n> \n> then inside the data layer, we have a simple check:\n> if context['superuser']:\n>  # don't limit the sql\n> elif context['project_id']:\n>  # add project_id = context\n> else:\n>   raise\n> switch on deleted to add deleted=0, deleted=1 or ignore\n> \n> The user_id and request_id aren't used in the datalayer but are in\n> context to help with logging.\n> \n> On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n> \n>> On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n>> \n>>> Now that I think about it, I'm not sure how they're supposed to work?\n>>> They're applied before the object(s) being accessed are even known, so\n>>> it only really checks if context.user has the given role on\n>>> context.project, right? So any checks further down should check whether\n>>> the object being accessed belongs to context.project. Is that accurate?\n>>> \n>> \n>> Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n>> unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n>> might help clarify the code if that were renamed to \"MethodAuthentication\"\n>> and we do data authentication somewhere else.\n>> \n>> \n>> Confidentiality Notice: This e-mail message (including any attached or\n>> embedded documents) is intended for the exclusive and confidential use of the\n>> individual or entity to which this message is addressed, and unless otherwise\n>> expressly indicated, is confidential and privileged information of Rackspace.\n>> Any dissemination, distribution or copying of the enclosed material is prohibited.\n>> If you receive this transmission in error, please notify us immediately by e-mail\n>> at <email address hidden>, and delete the original message.\n>> Your cooperation is appreciated.\n>> \n>> -- \n>> authorization not checked in ec2 api\n>> https://bugs.launchpad.net/bugs/644092\n>> You received this bug notification because you are a member of Nova\n>> Bugs, which is subscribed to OpenStack Compute (nova).\n>> \n>> Status in OpenStack Compute (Nova): New\n>> \n>> Bug description:\n>> Users can see things they shouldn't be able to.\n>> \n>> STEPS:\n>> \n>> 0) create two users a & b, NOT in the same project\n>> \n>> 1) start an instance as user a\n>> \n>> 2) get_console_output on user a's instance as user b\n>> \n>> EXPECTED:\n>> \n>>  the user should not get the output (user b should not be able to get console output for instances they don't own)\n>> \n>> ACTUAL:\n>> \n>>  console output from instance is returned successfully\n>> \n>> DETAILS:\n>> \n>> for instance, get_console_output in cloud.py:\n>> \n>>   def get_console_output(self, context, instance_id, **kwargs):\n>>       instance_ref = db.instance_get_by_str(context, instance_id[0])\n>>       return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>>                                  instance_ref['host']),\n>>                       {\"method\": \"get_console_output\",\n>>                        \"args\": {\"context\": None,\n>>                                 \"instance_id\": instance_ref['id']}})\n>> \n>> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n>> \n>> Similarly for all other data store objects.\n>> \n>> PROPOSAL:\n>> \n>> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n>> \n>> \n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>   the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>   console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> \n> \n", 
            "date_created": "2010-09-21 18:58:28+00:00", 
            "author": "https://api.launchpad.net/1.0/~devcamcar"
        }, 
        {
            "content": "I like the practice of providing context all the way down the call stack.  However I think first class citizens should not be dictionaries.  We can accomplish the same thing with a proper object that implements todict()/fromdict().\n\nDevin\n\n\nOn Sep 21, 2010, at 11:18 AM, vishvananda wrote:\n\n> My thoughts on data authentication:\n> First we turn context into a dictionary so it is easy to pass around everywhere.   The dictionary contains the following important data:\n> {'request_id': <random req string>,\n> 'user_id': ...,\n> 'project_id': ...,\n> 'superuser': <boolean, for bypassing project checking>\n> 'deleted' <tristate yes, no, all>}\n> \n> superuser is set during authentication of the request, simply to avoid\n> roundtrips to the auth layer.\n> \n> My preference for a dictionary is simply that it is easy to pass through\n> rabbit.\n> \n> then inside the data layer, we have a simple check:\n> if context['superuser']:\n> # don't limit the sql\n> elif context['project_id']:\n> # add project_id = context\n> else:\n>  raise\n> switch on deleted to add deleted=0, deleted=1 or ignore\n> \n> The user_id and request_id aren't used in the datalayer but are in\n> context to help with logging.\n> \n> On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n> \n>> On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n>> \n>>> Now that I think about it, I'm not sure how they're supposed to work?\n>>> They're applied before the object(s) being accessed are even known, so\n>>> it only really checks if context.user has the given role on\n>>> context.project, right? So any checks further down should check whether\n>>> the object being accessed belongs to context.project. Is that accurate?\n>>> \n>> \n>> Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n>> unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n>> might help clarify the code if that were renamed to \"MethodAuthentication\"\n>> and we do data authentication somewhere else.\n>> \n>> \n>> Confidentiality Notice: This e-mail message (including any attached or\n>> embedded documents) is intended for the exclusive and confidential use of the\n>> individual or entity to which this message is addressed, and unless otherwise\n>> expressly indicated, is confidential and privileged information of Rackspace.\n>> Any dissemination, distribution or copying of the enclosed material is prohibited.\n>> If you receive this transmission in error, please notify us immediately by e-mail\n>> at <email address hidden>, and delete the original message.\n>> Your cooperation is appreciated.\n>> \n>> -- \n>> authorization not checked in ec2 api\n>> https://bugs.launchpad.net/bugs/644092\n>> You received this bug notification because you are a member of Nova\n>> Bugs, which is subscribed to OpenStack Compute (nova).\n>> \n>> Status in OpenStack Compute (Nova): New\n>> \n>> Bug description:\n>> Users can see things they shouldn't be able to.\n>> \n>> STEPS:\n>> \n>> 0) create two users a & b, NOT in the same project\n>> \n>> 1) start an instance as user a\n>> \n>> 2) get_console_output on user a's instance as user b\n>> \n>> EXPECTED:\n>> \n>> the user should not get the output (user b should not be able to get console output for instances they don't own)\n>> \n>> ACTUAL:\n>> \n>> console output from instance is returned successfully\n>> \n>> DETAILS:\n>> \n>> for instance, get_console_output in cloud.py:\n>> \n>>  def get_console_output(self, context, instance_id, **kwargs):\n>>      instance_ref = db.instance_get_by_str(context, instance_id[0])\n>>      return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>>                                 instance_ref['host']),\n>>                      {\"method\": \"get_console_output\",\n>>                       \"args\": {\"context\": None,\n>>                                \"instance_id\": instance_ref['id']}})\n>> \n>> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n>> \n>> Similarly for all other data store objects.\n>> \n>> PROPOSAL:\n>> \n>> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n>> \n>> \n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>  the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>  console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>   def get_console_output(self, context, instance_id, **kwargs):\n>       instance_ref = db.instance_get_by_str(context, instance_id[0])\n>       return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                  instance_ref['host']),\n>                       {\"method\": \"get_console_output\",\n>                        \"args\": {\"context\": None,\n>                                 \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> \n> \n\n", 
            "date_created": "2010-09-21 19:06:04+00:00", 
            "author": "https://api.launchpad.net/1.0/~devcamcar"
        }, 
        {
            "content": "WSGI has an environ dictionary that is for storing context about the\nrequest; would it make sense to replace APIRequestContext entirely, just\npassing the environ dict around?  Pro: reuses WSGI concept.  Con: passing\naround a dictionary that has more info in it than strictly needed; risks\ncoupling the code to WSGI more tightly.\n\n- Michael\n\nOn Tue, Sep 21, 2010 at 2:18 PM, vishvananda <email address hidden> wrote:\n\n> My thoughts on data authentication:\n> First we turn context into a dictionary so it is easy to pass around\n> everywhere.   The dictionary contains the following important data:\n> {'request_id': <random req string>,\n>  'user_id': ...,\n>  'project_id': ...,\n>  'superuser': <boolean, for bypassing project checking>\n>  'deleted' <tristate yes, no, all>}\n>\n> superuser is set during authentication of the request, simply to avoid\n> roundtrips to the auth layer.\n>\n> My preference for a dictionary is simply that it is easy to pass through\n> rabbit.\n>\n> then inside the data layer, we have a simple check:\n> if context['superuser']:\n>  # don't limit the sql\n> elif context['project_id']:\n>  # add project_id = context\n> else:\n>   raise\n> switch on deleted to add deleted=0, deleted=1 or ignore\n>\n> The user_id and request_id aren't used in the datalayer but are in\n> context to help with logging.\n>\n> On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n>\n> > On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n> >\n> >> Now that I think about it, I'm not sure how they're supposed to work?\n> >> They're applied before the object(s) being accessed are even known, so\n> >> it only really checks if context.user has the given role on\n> >> context.project, right? So any checks further down should check whether\n> >> the object being accessed belongs to context.project. Is that accurate?\n> >>\n> >\n> > Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n> > unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n> > might help clarify the code if that were renamed to\n> \"MethodAuthentication\"\n> > and we do data authentication somewhere else.\n> >\n> >\n> > Confidentiality Notice: This e-mail message (including any attached or\n> > embedded documents) is intended for the exclusive and confidential use of\n> the\n> > individual or entity to which this message is addressed, and unless\n> otherwise\n> > expressly indicated, is confidential and privileged information of\n> Rackspace.\n> > Any dissemination, distribution or copying of the enclosed material is\n> prohibited.\n> > If you receive this transmission in error, please notify us immediately\n> by e-mail\n> > at <email address hidden>, and delete the original message.\n> > Your cooperation is appreciated.\n> >\n> > --\n> > authorization not checked in ec2 api\n> > https://bugs.launchpad.net/bugs/644092\n> > You received this bug notification because you are a member of Nova\n> > Bugs, which is subscribed to OpenStack Compute (nova).\n> >\n> > Status in OpenStack Compute (Nova): New\n> >\n> > Bug description:\n> > Users can see things they shouldn't be able to.\n> >\n> > STEPS:\n> >\n> > 0) create two users a & b, NOT in the same project\n> >\n> > 1) start an instance as user a\n> >\n> > 2) get_console_output on user a's instance as user b\n> >\n> > EXPECTED:\n> >\n> >   the user should not get the output (user b should not be able to get\n> console output for instances they don't own)\n> >\n> > ACTUAL:\n> >\n> >   console output from instance is returned successfully\n> >\n> > DETAILS:\n> >\n> > for instance, get_console_output in cloud.py:\n> >\n> >    def get_console_output(self, context, instance_id, **kwargs):\n> >        instance_ref = db.instance_get_by_str(context, instance_id[0])\n> >        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n> >                                   instance_ref['host']),\n> >                        {\"method\": \"get_console_output\",\n> >                         \"args\": {\"context\": None,\n> >                                  \"instance_id\": instance_ref['id']}})\n> >\n> > sends a context (which has the user/project) into the instance_get_by_str\n> function, but context is not used in the db layer to determine if the user\n> has access to the instance.\n> >\n> > Similarly for all other data store objects.\n> >\n> > PROPOSAL:\n> >\n> > My thought is that the datalayer should only return objects that the user\n> is authorized to see.  If we check at the API layer instead of the data\n> access layer, we have the possibility of inconsistent rules for the same\n> data types as the API evolves.\n> >\n> >\n>\n> --\n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n>\n> Status in OpenStack Compute (Nova): New\n>\n> Bug description:\n> Users can see things they shouldn't be able to.\n>\n> STEPS:\n>\n> 0) create two users a & b, NOT in the same project\n>\n> 1) start an instance as user a\n>\n> 2) get_console_output on user a's instance as user b\n>\n> EXPECTED:\n>\n>   the user should not get the output (user b should not be able to get\n> console output for instances they don't own)\n>\n> ACTUAL:\n>\n>   console output from instance is returned successfully\n>\n> DETAILS:\n>\n> for instance, get_console_output in cloud.py:\n>\n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n>\n> sends a context (which has the user/project) into the instance_get_by_str\n> function, but context is not used in the db layer to determine if the user\n> has access to the instance.\n>\n> Similarly for all other data store objects.\n>\n> PROPOSAL:\n>\n> My thought is that the datalayer should only return objects that the user\n> is authorized to see.  If we check at the API layer instead of the data\n> access layer, we have the possibility of inconsistent rules for the same\n> data types as the API evolves.\n>\n>\n>\n\n\nConfidentiality Notice: This e-mail message (including any attached or\nembedded documents) is intended for the exclusive and confidential use of the\nindividual or entity to which this message is addressed, and unless otherwise\nexpressly indicated, is confidential and privileged information of Rackspace.\nAny dissemination, distribution or copying of the enclosed material is prohibited.\nIf you receive this transmission in error, please notify us immediately by e-mail\nat <email address hidden>, and delete the original message.\nYour cooperation is appreciated.\n\n", 
            "date_created": "2010-09-21 19:06:56+00:00", 
            "author": "https://api.launchpad.net/1.0/~gundlach"
        }, 
        {
            "content": "The term \"proper object\" isn't very pythonic, silly Devin man. Nothin wrong\nwith a dict - it's a \"proper object\", too.\n\nOn Tue, Sep 21, 2010 at 9:06 PM, Devin Carlen <email address hidden>wrote:\n\n> I like the practice of providing context all the way down the call\n> stack.  However I think first class citizens should not be dictionaries.\n> We can accomplish the same thing with a proper object that implements\n> todict()/fromdict().\n>\n> Devin\n>\n>\n> On Sep 21, 2010, at 11:18 AM, vishvananda wrote:\n>\n> > My thoughts on data authentication:\n> > First we turn context into a dictionary so it is easy to pass around\n> everywhere.   The dictionary contains the following important data:\n> > {'request_id': <random req string>,\n> > 'user_id': ...,\n> > 'project_id': ...,\n> > 'superuser': <boolean, for bypassing project checking>\n> > 'deleted' <tristate yes, no, all>}\n> >\n> > superuser is set during authentication of the request, simply to avoid\n> > roundtrips to the auth layer.\n> >\n> > My preference for a dictionary is simply that it is easy to pass through\n> > rabbit.\n> >\n> > then inside the data layer, we have a simple check:\n> > if context['superuser']:\n> > # don't limit the sql\n> > elif context['project_id']:\n> > # add project_id = context\n> > else:\n> >  raise\n> > switch on deleted to add deleted=0, deleted=1 or ignore\n> >\n> > The user_id and request_id aren't used in the datalayer but are in\n> > context to help with logging.\n> >\n> > On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n> >\n> >> On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n> >>\n> >>> Now that I think about it, I'm not sure how they're supposed to work?\n> >>> They're applied before the object(s) being accessed are even known, so\n> >>> it only really checks if context.user has the given role on\n> >>> context.project, right? So any checks further down should check whether\n> >>> the object being accessed belongs to context.project. Is that accurate?\n> >>>\n> >>\n> >> Yep, that's accurate.  The conversion from Tornado to eventlet (as of\n> yet\n> >> unmerged to trunk) moves all that into an \"Authorization\" middleware.\n>  It\n> >> might help clarify the code if that were renamed to\n> \"MethodAuthentication\"\n> >> and we do data authentication somewhere else.\n> >>\n> >>\n> >> Confidentiality Notice: This e-mail message (including any attached or\n> >> embedded documents) is intended for the exclusive and confidential use\n> of the\n> >> individual or entity to which this message is addressed, and unless\n> otherwise\n> >> expressly indicated, is confidential and privileged information of\n> Rackspace.\n> >> Any dissemination, distribution or copying of the enclosed material is\n> prohibited.\n> >> If you receive this transmission in error, please notify us immediately\n> by e-mail\n> >> at <email address hidden>, and delete the original message.\n> >> Your cooperation is appreciated.\n> >>\n> >> --\n> >> authorization not checked in ec2 api\n> >> https://bugs.launchpad.net/bugs/644092\n> >> You received this bug notification because you are a member of Nova\n> >> Bugs, which is subscribed to OpenStack Compute (nova).\n> >>\n> >> Status in OpenStack Compute (Nova): New\n> >>\n> >> Bug description:\n> >> Users can see things they shouldn't be able to.\n> >>\n> >> STEPS:\n> >>\n> >> 0) create two users a & b, NOT in the same project\n> >>\n> >> 1) start an instance as user a\n> >>\n> >> 2) get_console_output on user a's instance as user b\n> >>\n> >> EXPECTED:\n> >>\n> >> the user should not get the output (user b should not be able to get\n> console output for instances they don't own)\n> >>\n> >> ACTUAL:\n> >>\n> >> console output from instance is returned successfully\n> >>\n> >> DETAILS:\n> >>\n> >> for instance, get_console_output in cloud.py:\n> >>\n> >>  def get_console_output(self, context, instance_id, **kwargs):\n> >>      instance_ref = db.instance_get_by_str(context, instance_id[0])\n> >>      return rpc.call('%s.%s' % (FLAGS.compute_topic,\n> >>                                 instance_ref['host']),\n> >>                      {\"method\": \"get_console_output\",\n> >>                       \"args\": {\"context\": None,\n> >>                                \"instance_id\": instance_ref['id']}})\n> >>\n> >> sends a context (which has the user/project) into the\n> instance_get_by_str function, but context is not used in the db layer to\n> determine if the user has access to the instance.\n> >>\n> >> Similarly for all other data store objects.\n> >>\n> >> PROPOSAL:\n> >>\n> >> My thought is that the datalayer should only return objects that the\n> user is authorized to see.  If we check at the API layer instead of the data\n> access layer, we have the possibility of inconsistent rules for the same\n> data types as the API evolves.\n> >>\n> >>\n> >\n> > --\n> > authorization not checked in ec2 api\n> > https://bugs.launchpad.net/bugs/644092\n> > You received this bug notification because you are a member of Nova\n> > Bugs, which is subscribed to OpenStack Compute (nova).\n> >\n> > Status in OpenStack Compute (Nova): New\n> >\n> > Bug description:\n> > Users can see things they shouldn't be able to.\n> >\n> > STEPS:\n> >\n> > 0) create two users a & b, NOT in the same project\n> >\n> > 1) start an instance as user a\n> >\n> > 2) get_console_output on user a's instance as user b\n> >\n> > EXPECTED:\n> >\n> >  the user should not get the output (user b should not be able to get\n> console output for instances they don't own)\n> >\n> > ACTUAL:\n> >\n> >  console output from instance is returned successfully\n> >\n> > DETAILS:\n> >\n> > for instance, get_console_output in cloud.py:\n> >\n> >   def get_console_output(self, context, instance_id, **kwargs):\n> >       instance_ref = db.instance_get_by_str(context, instance_id[0])\n> >       return rpc.call('%s.%s' % (FLAGS.compute_topic,\n> >                                  instance_ref['host']),\n> >                       {\"method\": \"get_console_output\",\n> >                        \"args\": {\"context\": None,\n> >                                 \"instance_id\": instance_ref['id']}})\n> >\n> > sends a context (which has the user/project) into the instance_get_by_str\n> function, but context is not used in the db layer to determine if the user\n> has access to the instance.\n> >\n> > Similarly for all other data store objects.\n> >\n> > PROPOSAL:\n> >\n> > My thought is that the datalayer should only return objects that the user\n> is authorized to see.  If we check at the API layer instead of the data\n> access layer, we have the possibility of inconsistent rules for the same\n> data types as the API evolves.\n> >\n> >\n>\n> --\n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n>\n> Status in OpenStack Compute (Nova): New\n>\n> Bug description:\n> Users can see things they shouldn't be able to.\n>\n> STEPS:\n>\n> 0) create two users a & b, NOT in the same project\n>\n> 1) start an instance as user a\n>\n> 2) get_console_output on user a's instance as user b\n>\n> EXPECTED:\n>\n>   the user should not get the output (user b should not be able to get\n> console output for instances they don't own)\n>\n> ACTUAL:\n>\n>   console output from instance is returned successfully\n>\n> DETAILS:\n>\n> for instance, get_console_output in cloud.py:\n>\n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n>\n> sends a context (which has the user/project) into the instance_get_by_str\n> function, but context is not used in the db layer to determine if the user\n> has access to the instance.\n>\n> Similarly for all other data store objects.\n>\n> PROPOSAL:\n>\n> My thought is that the datalayer should only return objects that the user\n> is authorized to see.  If we check at the API layer instead of the data\n> access layer, we have the possibility of inconsistent rules for the same\n> data types as the API evolves.\n>\n>\n>\n", 
            "date_created": "2010-09-21 19:44:36+00:00", 
            "author": "https://api.launchpad.net/1.0/~joshua-mckenty"
        }, 
        {
            "content": "I would vote sticking with an object or dict, as the context may\nbe passed over the message bus to workers. Most of the WSGI environ\nmembers won't make much sense in the worker process.\n\n-Eric\n\nOn Tue, Sep 21, 2010 at 07:06:56PM -0000, Michael Gundlach wrote:\n> WSGI has an environ dictionary that is for storing context about the\n> request; would it make sense to replace APIRequestContext entirely, just\n> passing the environ dict around?  Pro: reuses WSGI concept.  Con: passing\n> around a dictionary that has more info in it than strictly needed; risks\n> coupling the code to WSGI more tightly.\n> \n> - Michael\n> \n> On Tue, Sep 21, 2010 at 2:18 PM, vishvananda <email address hidden>\n> wrote:\n> \n> > My thoughts on data authentication:\n> > First we turn context into a dictionary so it is easy to pass around\n> > everywhere.   The dictionary contains the following important data:\n> > {'request_id': <random req string>,\n> >  'user_id': ...,\n> >  'project_id': ...,\n> >  'superuser': <boolean, for bypassing project checking>\n> >  'deleted' <tristate yes, no, all>}\n> >\n> > superuser is set during authentication of the request, simply to avoid\n> > roundtrips to the auth layer.\n> >\n> > My preference for a dictionary is simply that it is easy to pass through\n> > rabbit.\n> >\n> > then inside the data layer, we have a simple check:\n> > if context['superuser']:\n> >  # don't limit the sql\n> > elif context['project_id']:\n> >  # add project_id = context\n> > else:\n> >   raise\n> > switch on deleted to add deleted=0, deleted=1 or ignore\n> >\n> > The user_id and request_id aren't used in the datalayer but are in\n> > context to help with logging.\n> >\n> > On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n> >\n> > > On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n> > >\n> > >> Now that I think about it, I'm not sure how they're supposed to work?\n> > >> They're applied before the object(s) being accessed are even known, so\n> > >> it only really checks if context.user has the given role on\n> > >> context.project, right? So any checks further down should check whether\n> > >> the object being accessed belongs to context.project. Is that accurate?\n> > >>\n> > >\n> > > Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n> > > unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n> > > might help clarify the code if that were renamed to\n> > \"MethodAuthentication\"\n> > > and we do data authentication somewhere else.\n> > >\n> > >\n> > > Confidentiality Notice: This e-mail message (including any attached or\n> > > embedded documents) is intended for the exclusive and confidential use of\n> > the\n> > > individual or entity to which this message is addressed, and unless\n> > otherwise\n> > > expressly indicated, is confidential and privileged information of\n> > Rackspace.\n> > > Any dissemination, distribution or copying of the enclosed material is\n> > prohibited.\n> > > If you receive this transmission in error, please notify us immediately\n> > by e-mail\n> > > at <email address hidden>, and delete the original message.\n> > > Your cooperation is appreciated.\n> > >\n> > > --\n> > > authorization not checked in ec2 api\n> > > https://bugs.launchpad.net/bugs/644092\n> > > You received this bug notification because you are a member of Nova\n> > > Bugs, which is subscribed to OpenStack Compute (nova).\n> > >\n> > > Status in OpenStack Compute (Nova): New\n> > >\n> > > Bug description:\n> > > Users can see things they shouldn't be able to.\n> > >\n> > > STEPS:\n> > >\n> > > 0) create two users a & b, NOT in the same project\n> > >\n> > > 1) start an instance as user a\n> > >\n> > > 2) get_console_output on user a's instance as user b\n> > >\n> > > EXPECTED:\n> > >\n> > >   the user should not get the output (user b should not be able to get\n> > console output for instances they don't own)\n> > >\n> > > ACTUAL:\n> > >\n> > >   console output from instance is returned successfully\n> > >\n> > > DETAILS:\n> > >\n> > > for instance, get_console_output in cloud.py:\n> > >\n> > >    def get_console_output(self, context, instance_id, **kwargs):\n> > >        instance_ref = db.instance_get_by_str(context, instance_id[0])\n> > >        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n> > >                                   instance_ref['host']),\n> > >                        {\"method\": \"get_console_output\",\n> > >                         \"args\": {\"context\": None,\n> > >                                  \"instance_id\": instance_ref['id']}})\n> > >\n> > > sends a context (which has the user/project) into the instance_get_by_str\n> > function, but context is not used in the db layer to determine if the user\n> > has access to the instance.\n> > >\n> > > Similarly for all other data store objects.\n> > >\n> > > PROPOSAL:\n> > >\n> > > My thought is that the datalayer should only return objects that the user\n> > is authorized to see.  If we check at the API layer instead of the data\n> > access layer, we have the possibility of inconsistent rules for the same\n> > data types as the API evolves.\n> > >\n> > >\n> >\n> > --\n> > authorization not checked in ec2 api\n> > https://bugs.launchpad.net/bugs/644092\n> > You received this bug notification because you are a member of Nova\n> > Bugs, which is subscribed to OpenStack Compute (nova).\n> >\n> > Status in OpenStack Compute (Nova): New\n> >\n> > Bug description:\n> > Users can see things they shouldn't be able to.\n> >\n> > STEPS:\n> >\n> > 0) create two users a & b, NOT in the same project\n> >\n> > 1) start an instance as user a\n> >\n> > 2) get_console_output on user a's instance as user b\n> >\n> > EXPECTED:\n> >\n> >   the user should not get the output (user b should not be able to get\n> > console output for instances they don't own)\n> >\n> > ACTUAL:\n> >\n> >   console output from instance is returned successfully\n> >\n> > DETAILS:\n> >\n> > for instance, get_console_output in cloud.py:\n> >\n> >    def get_console_output(self, context, instance_id, **kwargs):\n> >        instance_ref = db.instance_get_by_str(context, instance_id[0])\n> >        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n> >                                   instance_ref['host']),\n> >                        {\"method\": \"get_console_output\",\n> >                         \"args\": {\"context\": None,\n> >                                  \"instance_id\": instance_ref['id']}})\n> >\n> > sends a context (which has the user/project) into the instance_get_by_str\n> > function, but context is not used in the db layer to determine if the user\n> > has access to the instance.\n> >\n> > Similarly for all other data store objects.\n> >\n> > PROPOSAL:\n> >\n> > My thought is that the datalayer should only return objects that the user\n> > is authorized to see.  If we check at the API layer instead of the data\n> > access layer, we have the possibility of inconsistent rules for the same\n> > data types as the API evolves.\n> >\n> >\n> >\n> \n> \n> Confidentiality Notice: This e-mail message (including any attached or\n> embedded documents) is intended for the exclusive and confidential use of the\n> individual or entity to which this message is addressed, and unless otherwise\n> expressly indicated, is confidential and privileged information of Rackspace.\n> Any dissemination, distribution or copying of the enclosed material is prohibited.\n> If you receive this transmission in error, please notify us immediately by e-mail\n> at <email address hidden>, and delete the original message.\n> Your cooperation is appreciated.\n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>    the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>    console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>     def get_console_output(self, context, instance_id, **kwargs):\n>         instance_ref = db.instance_get_by_str(context, instance_id[0])\n>         return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                    instance_ref['host']),\n>                         {\"method\": \"get_console_output\",\n>                          \"args\": {\"context\": None,\n>                                   \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> ", 
            "date_created": "2010-09-21 19:52:18+00:00", 
            "author": "https://api.launchpad.net/1.0/~eday"
        }, 
        {
            "content": "I don't think the WSGI context will be of any use and we'd have to modify it along the way.  The context object Vish proposed contains only information specific to Nova.\n\nDevin\n\n\nOn Sep 21, 2010, at 12:52 PM, Eric Day wrote:\n\n> I would vote sticking with an object or dict, as the context may\n> be passed over the message bus to workers. Most of the WSGI environ\n> members won't make much sense in the worker process.\n> \n> -Eric\n> \n> On Tue, Sep 21, 2010 at 07:06:56PM -0000, Michael Gundlach wrote:\n>> WSGI has an environ dictionary that is for storing context about the\n>> request; would it make sense to replace APIRequestContext entirely, just\n>> passing the environ dict around?  Pro: reuses WSGI concept.  Con: passing\n>> around a dictionary that has more info in it than strictly needed; risks\n>> coupling the code to WSGI more tightly.\n>> \n>> - Michael\n>> \n>> On Tue, Sep 21, 2010 at 2:18 PM, vishvananda <email address hidden>\n>> wrote:\n>> \n>>> My thoughts on data authentication:\n>>> First we turn context into a dictionary so it is easy to pass around\n>>> everywhere.   The dictionary contains the following important data:\n>>> {'request_id': <random req string>,\n>>> 'user_id': ...,\n>>> 'project_id': ...,\n>>> 'superuser': <boolean, for bypassing project checking>\n>>> 'deleted' <tristate yes, no, all>}\n>>> \n>>> superuser is set during authentication of the request, simply to avoid\n>>> roundtrips to the auth layer.\n>>> \n>>> My preference for a dictionary is simply that it is easy to pass through\n>>> rabbit.\n>>> \n>>> then inside the data layer, we have a simple check:\n>>> if context['superuser']:\n>>> # don't limit the sql\n>>> elif context['project_id']:\n>>> # add project_id = context\n>>> else:\n>>>  raise\n>>> switch on deleted to add deleted=0, deleted=1 or ignore\n>>> \n>>> The user_id and request_id aren't used in the datalayer but are in\n>>> context to help with logging.\n>>> \n>>> On Sep 21, 2010, at 8:52 AM, Michael Gundlach wrote:\n>>> \n>>>> On Tue, Sep 21, 2010 at 8:16 AM, Soren Hansen <email address hidden> wrote:\n>>>> \n>>>>> Now that I think about it, I'm not sure how they're supposed to work?\n>>>>> They're applied before the object(s) being accessed are even known, so\n>>>>> it only really checks if context.user has the given role on\n>>>>> context.project, right? So any checks further down should check whether\n>>>>> the object being accessed belongs to context.project. Is that accurate?\n>>>>> \n>>>> \n>>>> Yep, that's accurate.  The conversion from Tornado to eventlet (as of yet\n>>>> unmerged to trunk) moves all that into an \"Authorization\" middleware.  It\n>>>> might help clarify the code if that were renamed to\n>>> \"MethodAuthentication\"\n>>>> and we do data authentication somewhere else.\n>>>> \n>>>> \n>>>> Confidentiality Notice: This e-mail message (including any attached or\n>>>> embedded documents) is intended for the exclusive and confidential use of\n>>> the\n>>>> individual or entity to which this message is addressed, and unless\n>>> otherwise\n>>>> expressly indicated, is confidential and privileged information of\n>>> Rackspace.\n>>>> Any dissemination, distribution or copying of the enclosed material is\n>>> prohibited.\n>>>> If you receive this transmission in error, please notify us immediately\n>>> by e-mail\n>>>> at <email address hidden>, and delete the original message.\n>>>> Your cooperation is appreciated.\n>>>> \n>>>> --\n>>>> authorization not checked in ec2 api\n>>>> https://bugs.launchpad.net/bugs/644092\n>>>> You received this bug notification because you are a member of Nova\n>>>> Bugs, which is subscribed to OpenStack Compute (nova).\n>>>> \n>>>> Status in OpenStack Compute (Nova): New\n>>>> \n>>>> Bug description:\n>>>> Users can see things they shouldn't be able to.\n>>>> \n>>>> STEPS:\n>>>> \n>>>> 0) create two users a & b, NOT in the same project\n>>>> \n>>>> 1) start an instance as user a\n>>>> \n>>>> 2) get_console_output on user a's instance as user b\n>>>> \n>>>> EXPECTED:\n>>>> \n>>>>  the user should not get the output (user b should not be able to get\n>>> console output for instances they don't own)\n>>>> \n>>>> ACTUAL:\n>>>> \n>>>>  console output from instance is returned successfully\n>>>> \n>>>> DETAILS:\n>>>> \n>>>> for instance, get_console_output in cloud.py:\n>>>> \n>>>>   def get_console_output(self, context, instance_id, **kwargs):\n>>>>       instance_ref = db.instance_get_by_str(context, instance_id[0])\n>>>>       return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>>>>                                  instance_ref['host']),\n>>>>                       {\"method\": \"get_console_output\",\n>>>>                        \"args\": {\"context\": None,\n>>>>                                 \"instance_id\": instance_ref['id']}})\n>>>> \n>>>> sends a context (which has the user/project) into the instance_get_by_str\n>>> function, but context is not used in the db layer to determine if the user\n>>> has access to the instance.\n>>>> \n>>>> Similarly for all other data store objects.\n>>>> \n>>>> PROPOSAL:\n>>>> \n>>>> My thought is that the datalayer should only return objects that the user\n>>> is authorized to see.  If we check at the API layer instead of the data\n>>> access layer, we have the possibility of inconsistent rules for the same\n>>> data types as the API evolves.\n>>>> \n>>>> \n>>> \n>>> --\n>>> authorization not checked in ec2 api\n>>> https://bugs.launchpad.net/bugs/644092\n>>> You received this bug notification because you are a member of Nova\n>>> Bugs, which is subscribed to OpenStack Compute (nova).\n>>> \n>>> Status in OpenStack Compute (Nova): New\n>>> \n>>> Bug description:\n>>> Users can see things they shouldn't be able to.\n>>> \n>>> STEPS:\n>>> \n>>> 0) create two users a & b, NOT in the same project\n>>> \n>>> 1) start an instance as user a\n>>> \n>>> 2) get_console_output on user a's instance as user b\n>>> \n>>> EXPECTED:\n>>> \n>>>  the user should not get the output (user b should not be able to get\n>>> console output for instances they don't own)\n>>> \n>>> ACTUAL:\n>>> \n>>>  console output from instance is returned successfully\n>>> \n>>> DETAILS:\n>>> \n>>> for instance, get_console_output in cloud.py:\n>>> \n>>>   def get_console_output(self, context, instance_id, **kwargs):\n>>>       instance_ref = db.instance_get_by_str(context, instance_id[0])\n>>>       return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>>>                                  instance_ref['host']),\n>>>                       {\"method\": \"get_console_output\",\n>>>                        \"args\": {\"context\": None,\n>>>                                 \"instance_id\": instance_ref['id']}})\n>>> \n>>> sends a context (which has the user/project) into the instance_get_by_str\n>>> function, but context is not used in the db layer to determine if the user\n>>> has access to the instance.\n>>> \n>>> Similarly for all other data store objects.\n>>> \n>>> PROPOSAL:\n>>> \n>>> My thought is that the datalayer should only return objects that the user\n>>> is authorized to see.  If we check at the API layer instead of the data\n>>> access layer, we have the possibility of inconsistent rules for the same\n>>> data types as the API evolves.\n>>> \n>>> \n>>> \n>> \n>> \n>> Confidentiality Notice: This e-mail message (including any attached or\n>> embedded documents) is intended for the exclusive and confidential use of the\n>> individual or entity to which this message is addressed, and unless otherwise\n>> expressly indicated, is confidential and privileged information of Rackspace.\n>> Any dissemination, distribution or copying of the enclosed material is prohibited.\n>> If you receive this transmission in error, please notify us immediately by e-mail\n>> at <email address hidden>, and delete the original message.\n>> Your cooperation is appreciated.\n>> \n>> -- \n>> authorization not checked in ec2 api\n>> https://bugs.launchpad.net/bugs/644092\n>> You received this bug notification because you are a member of Nova\n>> Bugs, which is subscribed to OpenStack Compute (nova).\n>> \n>> Status in OpenStack Compute (Nova): New\n>> \n>> Bug description:\n>> Users can see things they shouldn't be able to.\n>> \n>> STEPS:\n>> \n>> 0) create two users a & b, NOT in the same project\n>> \n>> 1) start an instance as user a\n>> \n>> 2) get_console_output on user a's instance as user b\n>> \n>> EXPECTED:\n>> \n>>   the user should not get the output (user b should not be able to get console output for instances they don't own)\n>> \n>> ACTUAL:\n>> \n>>   console output from instance is returned successfully\n>> \n>> DETAILS:\n>> \n>> for instance, get_console_output in cloud.py:\n>> \n>>    def get_console_output(self, context, instance_id, **kwargs):\n>>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>>                                   instance_ref['host']),\n>>                        {\"method\": \"get_console_output\",\n>>                         \"args\": {\"context\": None,\n>>                                  \"instance_id\": instance_ref['id']}})\n>> \n>> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n>> \n>> Similarly for all other data store objects.\n>> \n>> PROPOSAL:\n>> \n>> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n>> \n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>   the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>   console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> \n> \n", 
            "date_created": "2010-09-21 22:01:37+00:00", 
            "author": "https://api.launchpad.net/1.0/~devcamcar"
        }, 
        {
            "content": "regardless of whether the context object is a dict or a class or a modified WSGI environ:\n\nDoes the idea of doing authorization at the data layer by checking against this variable (and hence always passing it in) seem like a good idea?\n\nRight now many of the RS API and workers use either {} or None...\n\nWe would have to change all of these...  (so regardless of what the context variable is, we need to send it to the workers when we do work)", 
            "date_created": "2010-09-21 22:47:46.147268+00:00", 
            "author": "https://api.launchpad.net/1.0/~anotherjesse"
        }, 
        {
            "content": "Soren wrote:\n\n\"Now that I think about it, I'm not sure how they're supposed to work? They're applied before the object(s) being accessed are even known, so it only really checks if context.user has the given role on context.project, right? So any checks further down should check whether the object being accessed belongs to context.project. Is that accurate?\" \n\nThis is what I am proposing.  That the datalayer should check to see if the project is allowed to access the object.", 
            "date_created": "2010-09-21 22:49:06.322209+00:00", 
            "author": "https://api.launchpad.net/1.0/~anotherjesse"
        }, 
        {
            "content": "++ data layer is last line of defense to prevent coding errors from presenting data that doesn't belong to the user in context.\n\n\nOn Sep 21, 2010, at 3:49 PM, anotherjesse wrote:\n\n> Soren wrote:\n> \n> \"Now that I think about it, I'm not sure how they're supposed to work?\n> They're applied before the object(s) being accessed are even known, so\n> it only really checks if context.user has the given role on\n> context.project, right? So any checks further down should check whether\n> the object being accessed belongs to context.project. Is that accurate?\"\n> \n> This is what I am proposing.  That the datalayer should check to see if\n> the project is allowed to access the object.\n> \n> -- \n> authorization not checked in ec2 api\n> https://bugs.launchpad.net/bugs/644092\n> You received this bug notification because you are a member of Nova\n> Bugs, which is subscribed to OpenStack Compute (nova).\n> \n> Status in OpenStack Compute (Nova): New\n> \n> Bug description:\n> Users can see things they shouldn't be able to.\n> \n> STEPS:\n> \n> 0) create two users a & b, NOT in the same project\n> \n> 1) start an instance as user a\n> \n> 2) get_console_output on user a's instance as user b\n> \n> EXPECTED:\n> \n>   the user should not get the output (user b should not be able to get console output for instances they don't own)\n> \n> ACTUAL:\n> \n>   console output from instance is returned successfully\n> \n> DETAILS:\n> \n> for instance, get_console_output in cloud.py:\n> \n>    def get_console_output(self, context, instance_id, **kwargs):\n>        instance_ref = db.instance_get_by_str(context, instance_id[0])\n>        return rpc.call('%s.%s' % (FLAGS.compute_topic,\n>                                   instance_ref['host']),\n>                        {\"method\": \"get_console_output\",\n>                         \"args\": {\"context\": None,\n>                                  \"instance_id\": instance_ref['id']}})\n> \n> sends a context (which has the user/project) into the instance_get_by_str function, but context is not used in the db layer to determine if the user has access to the instance.\n> \n> Similarly for all other data store objects.\n> \n> PROPOSAL:\n> \n> My thought is that the datalayer should only return objects that the user is authorized to see.  If we check at the API layer instead of the data access layer, we have the possibility of inconsistent rules for the same data types as the API evolves.\n> \n> \n", 
            "date_created": "2010-09-21 23:16:06+00:00", 
            "author": "https://api.launchpad.net/1.0/~devcamcar"
        }, 
        {
            "content": "Marking this Fix Committed as Devin's auth branch is now in trunk.", 
            "date_created": "2010-10-05 19:13:29.073730+00:00", 
            "author": "https://api.launchpad.net/1.0/~jaypipes"
        }
    ], 
    "closed": "2010-10-25 20:28:52.309732+00:00"
}