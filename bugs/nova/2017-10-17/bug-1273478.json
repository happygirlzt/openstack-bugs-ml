{
    "status": "Fix Released", 
    "last_updated": "2014-04-17 09:07:42.047214+00:00", 
    "description": "CPython logging library generates the string representation of the message to log under a lock.\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n\nNova will use the __str__ method of the NetworkInfoAsyncWrapper when logging a message as in:\n\nnova/virt/libvirt/driver.py:to_xml()\n\n        LOG.debug(_('Start to_xml instance=%(instance)s '\n                    'network_info=%(network_info)s '\n                    'disk_info=%(disk_info)s '\n                    'image_meta=%(image_meta)s rescue=%(rescue)s'\n                    'block_device_info=%(block_device_info)s'),\n                  {'instance': instance, 'network_info': network_info,\n                   'disk_info': disk_info, 'image_meta': image_meta,\n                   'rescue': rescue, 'block_device_info': block_device_info})\n\nCurrently this causes the __str__ method to be called under the logging lock:\n\n  File \"/usr/lib/python2.7/dist-packages/nova/virt/libvirt/driver.py\", line 3058, in to_xml\n    'rescue': rescue, 'block_device_info': block_device_info})\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1412, in debug\n    self.logger.debug(msg, *args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1128, in debug\n    self._log(DEBUG, msg, args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1258, in _log\n    self.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1268, in handle\n    self.callHandlers(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1308, in callHandlers\n    hdlr.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 748, in handle\n    self.emit(record)\n  File \"/usr/lib/python2.7/logging/handlers.py\", line 414, in emit\n    logging.FileHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 930, in emit\n    StreamHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 846, in emit\n    msg = self.format(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 723, in format\n    return fmt.format(record)\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/log.py\", line 517, in format\n    return logging.Formatter.format(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 464, in format\n    record.message = record.getMessage()\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 328, in getMessage\n    msg = msg % self.args\n  File \"/usr/lib/python2.7/dist-packages/nova/network/model.py\", line 383, in __str__\n    return self._sync_wrapper(fn, *args, **kwargs)\n\nThis then waits for an eventlet to complete. This eventlet may itself attempt to use a log message as it executes.\n\nThis sequence of operations can produce a deadlock between a greenlet thread waiting for the async operation to finish and the async job itself, if it decides to log a message.", 
    "tags": [
        "libvirt"
    ], 
    "importance": "Medium", 
    "heat": 36, 
    "link": "https://bugs.launchpad.net/nova/+bug/1273478", 
    "owner": "None", 
    "id": 1273478, 
    "index": 3776, 
    "openned": "2014-01-27 23:20:08.545539+00:00", 
    "created": "2014-01-27 23:20:08.545539+00:00", 
    "title": "NetworkInfoAsyncWrapper __str__ can cause deadlock when called from a log message", 
    "comments": [
        {
            "content": "CPython logging library generates the string representation of the message to log under a lock.\n\n    def handle(self, record):\n        \"\"\"\n        Conditionally emit the specified logging record.\n\n        Emission depends on filters which may have been added to the handler.\n        Wrap the actual emission of the record with acquisition/release of\n        the I/O thread lock. Returns whether the filter passed the record for\n        emission.\n        \"\"\"\n        rv = self.filter(record)\n        if rv:\n            self.acquire()\n            try:\n                self.emit(record)\n            finally:\n                self.release()\n        return rv\n\n\nNova will use the __str__ method of the NetworkInfoAsyncWrapper when logging a message as in:\n\nnova/virt/libvirt/driver.py:to_xml()\n\n        LOG.debug(_('Start to_xml instance=%(instance)s '\n                    'network_info=%(network_info)s '\n                    'disk_info=%(disk_info)s '\n                    'image_meta=%(image_meta)s rescue=%(rescue)s'\n                    'block_device_info=%(block_device_info)s'),\n                  {'instance': instance, 'network_info': network_info,\n                   'disk_info': disk_info, 'image_meta': image_meta,\n                   'rescue': rescue, 'block_device_info': block_device_info})\n\nCurrently this causes the __str__ method to be called under the logging lock:\n\n  File \"/usr/lib/python2.7/dist-packages/nova/virt/libvirt/driver.py\", line 3058, in to_xml\n    'rescue': rescue, 'block_device_info': block_device_info})\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1412, in debug\n    self.logger.debug(msg, *args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1128, in debug\n    self._log(DEBUG, msg, args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1258, in _log\n    self.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1268, in handle\n    self.callHandlers(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1308, in callHandlers\n    hdlr.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 748, in handle\n    self.emit(record)\n  File \"/usr/lib/python2.7/logging/handlers.py\", line 414, in emit\n    logging.FileHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 930, in emit\n    StreamHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 846, in emit\n    msg = self.format(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 723, in format\n    return fmt.format(record)\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/log.py\", line 517, in format\n    return logging.Formatter.format(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 464, in format\n    record.message = record.getMessage()\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 328, in getMessage\n    msg = msg % self.args\n  File \"/usr/lib/python2.7/dist-packages/nova/network/model.py\", line 383, in __str__\n    return self._sync_wrapper(fn, *args, **kwargs)\n\nThis then waits for an eventlet to complete. This eventlet may itself attempt to use a log message as it executes.\n\nThis sequence of operations can produce a deadlock between a greenlet thread waiting for the async operation to finish and the async job itself, if it decides to log a message.", 
            "date_created": "2014-01-27 23:20:08.545539+00:00", 
            "author": "https://api.launchpad.net/1.0/~5-roque"
        }, 
        {
            "content": "The information above is incomplete.\n\nThe python logging library uses a re-entrant lock. Logs do work if emitted from the same thread as the thread that call eventlet.spawn().\n\nThe code path that blocks in sync_wrapper() is called from the same thread in which the AsyncWrapper is created. As such the locking should succeed.\n\nAttempts to reproduce the problem with multiple threads (libvirt spawns its own thread) seem to indicate that a eventlet that is created in one thread but for which wait is called from a different thread lead to the process blocking. It is still unclear how asyncWrapper and the libvirt thread lead to the deadlock observed.\n\nTest script:\nimport sys\nimport os\n\nabsname = os.path.dirname(os.path.realpath(__file__))\ntop_dir = absname[:absname.find('nova/tests/network')]\nsys.path.append(top_dir)\n\nimport threading\nimport eventlet\n\nfrom oslo.config import cfg\nfrom nova.openstack.common import log as logging\nfrom nova.network import model\n\nfrom nova.openstack.common.gettextutils import _\nimport uuid\n\nCONF = cfg.CONF\nCONF.use_syslog = False\nCONF.log_file = 'nova-test.log'\nCONF.debug = True\nCONF.verbose = True\n\nlogging.setup('nova')\nLOG = logging.getLogger(__name__)\n\nclass MockInstance(dict):\n    def __init__(self):\n        self['uuid'] = uuid.uuid1()\n\n\nclass NetworkInfoAsyncWrapperTests(object):\n    def __init__(self):\n        self._ninfo = None\n\n    def create(self):\n        def async_wrapper():\n            # print threading.current_thread()\n            # LOG.debug(\" *** Lock inversion *** \")\n            return list()\n\n        self._ninfo = model.NetworkInfoAsyncWrapper(async_wrapper)\n\n    def log_and_str(self):\n        print \"log_and_str\"\n        instance = MockInstance()\n        import pdb; pdb.set_trace()\n        LOG.debug(_('NetworkInfo: %(network_info)s'),\n                  {'network_info': self._ninfo}, instance=instance)\n\n\nclass TestThread(object):\n    def __init__(self, runner):\n        self._main = threading.Thread(target = runner)\n\n    def wait(self):\n        self._main.start()\n        self._main.join()\n\nif __name__ == '__main__':\n    test_case = NetworkInfoAsyncWrapperTests()\n    test_case.create()\n    thread = TestThread(test_case.log_and_str)\n    thread.wait()\n\n\n", 
            "date_created": "2014-01-28 06:56:26.657399+00:00", 
            "author": "https://api.launchpad.net/1.0/~5-roque"
        }, 
        {
            "content": "The attached test script is a possible way to re-create this problem:\nRun with the command:\ntools/with_venv.sh python nova/tests/network/test_network_info_async.py\n\nWhen the deadlock was experienced in a running system the config option use_tpool was not set.\nThe other users of tpool are: guestfs and libvirt/driver.py\n\nThis is apparently a well known issue in libvirt:\n           # tpool.proxy_call creates a native thread. Due to limitations\n            # with eventlet locking we cannot use the logging API inside\n            # the called function.\n \n", 
            "date_created": "2014-01-29 01:33:10.448221+00:00", 
            "author": "https://api.launchpad.net/1.0/~5-roque"
        }, 
        {
            "content": "I reproduced the problem again and I believe i've a complete analysis: the problem is a simple deadlock situation with the logging lock.\n\nWhile executing, nova-compute sets a greenthread as the current_thread.\n\nrunning \n \"/usr/lib/python2.7/dist-packages/nova/openstack/common/periodic_task.py\", line 180, in run_periodic_tasks\n\n(Pdb) p threading.current_thread()\n<_GreenThread(GreenThread-3, <eventlet.greenthread.GreenThread object at 0x3643370>)>\n\nThus when the __str__ method of NetworkInfoAsyncWrapper is called (from a green thread) and while holding the logging lock and the async method is invoked by eventlet.spawn() (from a different green thread) the logging lock deadlocks.\n\nIn this set of traces, the libvirt spawn() method invokes __str__:\n(Pdb) traceback.print_stack(gl[0].gr_frame)\n  File \"/usr/lib/python2.7/dist-packages/eventlet/greenpool.py\", line 80, in _spawn_n_impl\n    func(*args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/rpc/amqp.py\", line 461, in _process_data\n    **args)\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/rpc/dispatcher.py\", line 172, in dispatch\n    result = getattr(proxyobj, method)(ctxt, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/exception.py\", line 73, in wrapped\n    return f(self, context, *args, **kw)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 229, in decorated_function\n    return function(self, context, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 294, in decorated_function\n    function(self, context, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 258, in decorated_function\n    return function(self, context, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 1623, in run_instance\n    do_run_instance()\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/lockutils.py\", line 246, in inner\n    return f(*args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 1622, in do_run_instance\n    legacy_bdm_in_spec)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 946, in _run_instance\n    instance, image_meta, legacy_bdm_in_spec)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 1037, in _build_instance\n    set_access_ip=set_access_ip)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 1417, in _spawn\n    block_device_info)\n  File \"/usr/lib/python2.7/dist-packages/nova/virt/libvirt/driver.py\", line 2067, in spawn\n    write_to_disk=True)\n  File \"/usr/lib/python2.7/dist-packages/nova/virt/libvirt/driver.py\", line 3058, in to_xml\n    'rescue': rescue, 'block_device_info': block_device_info})\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1412, in debug\n    self.logger.debug(msg, *args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1128, in debug\n    self._log(DEBUG, msg, args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1258, in _log\n    self.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1268, in handle\n    self.callHandlers(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1308, in callHandlers\n    hdlr.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 748, in handle\n    self.emit(record)\n  File \"/usr/lib/python2.7/logging/handlers.py\", line 414, in emit\n    logging.FileHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 930, in emit\n    StreamHandler.emit(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 846, in emit\n    msg = self.format(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 723, in format\n    return fmt.format(record)\n  File \"/usr/lib/python2.7/dist-packages/nova/openstack/common/log.py\", line 517, in format\n    return logging.Formatter.format(self, record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 464, in format\n    record.message = record.getMessage()\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 328, in getMessage\n    msg = msg % self.args\n  File \"/usr/lib/python2.7/dist-packages/nova/network/model.py\", line 383, in __str__\n    return self._sync_wrapper(fn, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/network/model.py\", line 366, in _sync_wrapper\n    self.wait()\n  File \"/usr/lib/python2.7/dist-packages/nova/network/model.py\", line 398, in wait\n    self[:] = self._gt.wait()\n  File \"/usr/lib/python2.7/dist-packages/eventlet/greenthread.py\", line 168, in wait\n    return self._exit_event.wait()\n  File \"/usr/lib/python2.7/dist-packages/eventlet/event.py\", line 116, in wait\n    return hubs.get_hub().switch()\n  File \"/usr/lib/python2.7/dist-packages/eventlet/hubs/hub.py\", line 187, in switch\n    return self.greenlet.switch()\n\nIt now holds the logging lock:\n(Pdb) hlist = [ o for o in gc.get_objects() if isinstance(o, logging.Handler)]\n(Pdb) [ h.lock for h in hlist ]\n[None, None, None, <_RLock owner=56898896 count=1>, <_RLock owner=None count=0>, <_RLock owner=None count=0>]\n(Pdb) print hex(56898896)\n0x3643550\n\nThis is the greenlet for which the stack trace was displayed above:\n(Pdb) gl = [ o for o in gc.get_objects() if id(o) == 0x3643550]\n(Pdb) p gl\n[<greenlet.greenlet object at 0x3643550>]\n\n\nIt is waiting for the following greenlet:\n\n(Pdb) traceback.print_stack(glist[8].gr_frame)\n  File \"/usr/lib/python2.7/dist-packages/eventlet/greenthread.py\", line 194, in main\n    result = function(*args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/compute/manager.py\", line 1238, in _allocate_network_async\n    dhcp_options=dhcp_options)\n  File \"/usr/lib/python2.7/dist-packages/nova/network/api.py\", line 49, in wrapper\n    res = f(self, context, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/nova/network/neutronv2/api.py\", line 335, in allocate_for_instance\n    security_group_ids, available_macs, dhcp_opts))\n  File \"/usr/lib/python2.7/dist-packages/nova/network/neutronv2/api.py\", line 182, in _create_port\n    port_id = port_client.create_port(port_req_body)['port']['id']\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/v2_0/client.py\", line 108, in with_params\n    ret = self.function(instance, *args, **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/v2_0/client.py\", line 308, in create_port\n    return self.post(self.ports_path, body=body)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/v2_0/client.py\", line 1188, in post\n    headers=headers, params=params)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/v2_0/client.py\", line 1103, in do_request\n    resp, replybody = self.httpclient.do_request(action, method, body=body)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/client.py\", line 185, in do_request\n    **kwargs)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/client.py\", line 153, in _cs_request\n    utils.http_log_resp(_logger, resp, body)\n  File \"/usr/lib/python2.7/dist-packages/neutronclient/common/utils.py\", line 179, in http_log_resp\n    _logger.debug(\"RESP:%s %s\\n\", resp, body)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1128, in debug\n    self._log(DEBUG, msg, args, **kwargs)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1258, in _log\n    self.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1268, in handle\n    self.callHandlers(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 1308, in callHandlers\n    hdlr.handle(record)\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 746, in handle\n    self.acquire()\n  File \"/usr/lib/python2.7/logging/__init__.py\", line 697, in acquire\n    self.lock.acquire()\n  File \"/usr/lib/python2.7/threading.py\", line 127, in acquire\n    rc = self.__block.acquire(blocking)\n  File \"/usr/lib/python2.7/dist-packages/eventlet/semaphore.py\", line 96, in acquire\n    hubs.get_hub().switch()\n  File \"/usr/lib/python2.7/dist-packages/eventlet/hubs/hub.py\", line 187, in switch\n    return self.greenlet.switch()\n\nSince the latter run is a different greenthread, and greenthreads are used as lock owners then a deadlock is established.\n\nConclusions:\n- __str__() and __repr__() should not wait for a asynchronous event to complete. This breaks the principle of least astonishment.\n", 
            "date_created": "2014-01-30 06:18:10.806392+00:00", 
            "author": "https://api.launchpad.net/1.0/~5-roque"
        }, 
        {
            "content": "Unit test that reproduces the bug.", 
            "date_created": "2014-01-30 06:49:14.607213+00:00", 
            "author": "https://api.launchpad.net/1.0/~5-roque"
        }, 
        {
            "content": "I wanted to mark this bug to Low priority because it happens only in debug. But I have increased the priority to Medium because it could happened in the gate.", 
            "date_created": "2014-02-05 13:39:13.693879+00:00", 
            "author": "https://api.launchpad.net/1.0/~sahid-ferdjaoui"
        }, 
        {
            "content": "https://review.openstack.org/#/c/71046/", 
            "date_created": "2014-02-06 16:20:01.636200+00:00", 
            "author": "https://api.launchpad.net/1.0/~sahid-ferdjaoui"
        }
    ], 
    "closed": "2014-03-05 13:12:01.598379+00:00"
}