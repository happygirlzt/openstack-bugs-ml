{
    "status": "Invalid", 
    "last_updated": "2014-05-01 18:58:08.668059+00:00", 
    "description": "An abbreviated version of the nova.compute.resource_tracker.update_available_resources() call:\n\n    def update_available_resource(self, context):\n        resources = self.driver.get_available_resource(self.nodename)\n...\n        self._report_hypervisor_resource_view(resources)\n...\n        # Grab all instances assigned to this node:\n        instances = instance_obj.InstanceList.get_by_host_and_node(\n            context, self.host, self.nodename)\n\n        # Now calculate usage based on instance utilization:\n        self._update_usage_from_instances(resources, instances)\n\nAnd the nova.compute.resource_tracker._update_usage_from_instances() call looks like this:\n\n    def _update_usage_from_instances(self, resources, instances):\n        \"\"\"Calculate resource usage based on instance utilization.  This is\n        different than the hypervisor's view as it will account for all\n        instances assigned to the local compute host, even if they are not\n        currently powered on.\n        \"\"\"\n        self.tracked_instances.clear()\n\n        # purge old stats\n        self.stats.clear()\n\n        # set some initial values, reserve room for host/hypervisor:\n        resources['local_gb_used'] = CONF.reserved_host_disk_mb / 1024\n        resources['memory_mb_used'] = CONF.reserved_host_memory_mb\n        resources['vcpus_used'] = 0\n        resources['free_ram_mb'] = (resources['memory_mb'] -\n                                    resources['memory_mb_used'])\n        resources['free_disk_gb'] = (resources['local_gb'] -\n                                     resources['local_gb_used'])\n        resources['current_workload'] = 0\n        resources['running_vms'] = 0\n\n        for instance in instances:\n            if instance['vm_state'] == vm_states.DELETED:\n                continue\n            else:\n                self._update_usage_from_instance(resources, instance)\n\nWhile it is true that the _report_hypervisor_resource_view() method uses the resources returned from the hypervisor, it does nothing more than write out some of the resource usage stats in a DEBUG log:\n\n        free_ram_mb = resources['memory_mb'] - resources['memory_mb_used']\n        free_disk_gb = resources['local_gb'] - resources['local_gb_used']\n\n        LOG.debug(_(\"Hypervisor: free ram (MB): %s\") % free_ram_mb)\n        LOG.debug(_(\"Hypervisor: free disk (GB): %s\") % free_disk_gb)\n\nI wonder what the point is of asking the virt driver to query for its resource usage information if the resource_tracker just proceeds to throw that information away? Given the fact that the update_available_resources() method holds a lock on the compute worker entirely and the fact that this periodic task interval is so frequent, I question whether it is prudent to make such calls to the hypervisor when they are not used.", 
    "tags": [
        "libvirt"
    ], 
    "importance": "Undecided", 
    "heat": 6, 
    "link": "https://bugs.launchpad.net/nova/+bug/1310110", 
    "owner": "None", 
    "id": 1310110, 
    "index": 6051, 
    "openned": "2014-04-19 22:01:32.531821+00:00", 
    "created": "2014-04-19 22:01:32.531821+00:00", 
    "title": "resource_tracker.update_available_resources() calls virt driver for resources, then promptly throws them away", 
    "comments": [
        {
            "content": "An abbreviated version of the nova.compute.resource_tracker.update_available_resources() call:\n\n    def update_available_resource(self, context):\n        resources = self.driver.get_available_resource(self.nodename)\n...\n        self._report_hypervisor_resource_view(resources)\n...\n        # Grab all instances assigned to this node:\n        instances = instance_obj.InstanceList.get_by_host_and_node(\n            context, self.host, self.nodename)\n\n        # Now calculate usage based on instance utilization:\n        self._update_usage_from_instances(resources, instances)\n\nAnd the nova.compute.resource_tracker._update_usage_from_instances() call looks like this:\n\n    def _update_usage_from_instances(self, resources, instances):\n        \"\"\"Calculate resource usage based on instance utilization.  This is\n        different than the hypervisor's view as it will account for all\n        instances assigned to the local compute host, even if they are not\n        currently powered on.\n        \"\"\"\n        self.tracked_instances.clear()\n\n        # purge old stats\n        self.stats.clear()\n\n        # set some initial values, reserve room for host/hypervisor:\n        resources['local_gb_used'] = CONF.reserved_host_disk_mb / 1024\n        resources['memory_mb_used'] = CONF.reserved_host_memory_mb\n        resources['vcpus_used'] = 0\n        resources['free_ram_mb'] = (resources['memory_mb'] -\n                                    resources['memory_mb_used'])\n        resources['free_disk_gb'] = (resources['local_gb'] -\n                                     resources['local_gb_used'])\n        resources['current_workload'] = 0\n        resources['running_vms'] = 0\n\n        for instance in instances:\n            if instance['vm_state'] == vm_states.DELETED:\n                continue\n            else:\n                self._update_usage_from_instance(resources, instance)\n\nWhile it is true that the _report_hypervisor_resource_view() method uses the resources returned from the hypervisor, it does nothing more than write out some of the resource usage stats in a DEBUG log:\n\n        free_ram_mb = resources['memory_mb'] - resources['memory_mb_used']\n        free_disk_gb = resources['local_gb'] - resources['local_gb_used']\n\n        LOG.debug(_(\"Hypervisor: free ram (MB): %s\") % free_ram_mb)\n        LOG.debug(_(\"Hypervisor: free disk (GB): %s\") % free_disk_gb)\n\nI wonder what the point is of asking the virt driver to query for its resource usage information if the resource_tracker just proceeds to throw that information away? Given the fact that the update_available_resources() method holds a lock on the compute worker entirely and the fact that this periodic task interval is so frequent, I question whether it is prudent to make such calls to the hypervisor when they are not used.", 
            "date_created": "2014-04-19 22:01:32.531821+00:00", 
            "author": "https://api.launchpad.net/1.0/~jaypipes"
        }, 
        {
            "content": "There are actually a few lines between `self._report_hypervisor_resource_view(resources)` and self._update_usage_from_instances(resources, instances)` that use it:\n\n        if 'pci_passthrough_devices' in resources:\n            if not self.pci_tracker:\n                self.pci_tracker = pci_manager.PciDevTracker()\n            self.pci_tracker.set_hvdevs(jsonutils.loads(resources.pop(\n                'pci_passthrough_devices')))\n\nInteresting point though...", 
            "date_created": "2014-05-01 18:58:07.973982+00:00", 
            "author": "https://api.launchpad.net/1.0/~sross-7"
        }
    ], 
    "closed": "2014-05-01 18:56:33.217539+00:00"
}