{
    "status": "Fix Released", 
    "last_updated": "2013-04-04 11:17:02.278222+00:00", 
    "description": "When the image cache manager runs, it only cleans up unused base disk images ... not kernels and ramdisks\n\nThis is clearly the understood behaviour of the code:\n\n    def _list_base_images(self, base_dir):\n        \"\"\"Return a list of the images present in _base.                                                                                    \n                                                                                                                                            \n        Determine what images we have on disk. There will be other files in                                                                 \n        this directory (for example kernels) so we only grab the ones which                                                                 \n        are the right length to be disk images.                                                                                             \n        ...\n        \"\"\"\n        digest_size = hashlib.sha1().digestsize * 2\n        for ent in os.listdir(base_dir):\n            if len(ent) == digest_size:\n                self._store_image(base_dir, ent, original=True)\n\nand it's only the base disk images which are stored using their sha1 sum as their filename:\n\n        if disk_images['kernel_id']:\n            fname = disk_images['kernel_id']\n            raw('kernel').cache(fetch_func=libvirt_utils.fetch_image,\n                                context=context,\n                                filename=fname,\n                                ...)\n            if disk_images['ramdisk_id']:\n                fname = disk_images['ramdisk_id']\n                raw('ramdisk').cache(fetch_func=libvirt_utils.fetch_image,\n                                     context=context,\n                                     filename=fname,\n                                     ...)\n\n        root_fname = hashlib.sha1(str(disk_images['image_id'])).hexdigest()\n        ...\n        if 'disk' in disk_mapping:\n            image('disk').cache(fetch_func=libvirt_utils.fetch_image,\n                                context=context,\n                                filename=root_fname,\n                                ...)\n\nAssuming I'm not missing something and it does make sense to clean these up, I guess we can:\n\n  1) start storing kernels and ramdisks using their sha1 sum as their filename or\n\n  2) have the image cache manager somehow recognize the kernel/ramdisk filenames as images to examine\n\nWe also need the image cache manager to track kernels and ramdisks as used images when listing instances\n\ni.e. need to include kernel_id and ramdisk_id here:\n\n            image_ref_str = str(instance['image_ref'])\n            local, remote, insts = self.used_images.get(image_ref_str,\n                                                        (0, 0, []))", 
    "tags": [], 
    "importance": "High", 
    "heat": 6, 
    "link": "https://bugs.launchpad.net/nova/+bug/1132138", 
    "owner": "https://api.launchpad.net/1.0/~markmc", 
    "id": 1132138, 
    "index": 980, 
    "created": "2013-02-23 15:25:04.837029+00:00", 
    "title": "Unused kernels and ramdisks not removed by libvirt image cache manager", 
    "comments": [
        {
            "content": "When the image cache manager runs, it only cleans up unused base disk images ... not kernels and ramdisks\n\nThis is clearly the understood behaviour of the code:\n\n    def _list_base_images(self, base_dir):\n        \"\"\"Return a list of the images present in _base.                                                                                    \n                                                                                                                                            \n        Determine what images we have on disk. There will be other files in                                                                 \n        this directory (for example kernels) so we only grab the ones which                                                                 \n        are the right length to be disk images.                                                                                             \n        ...\n        \"\"\"\n        digest_size = hashlib.sha1().digestsize * 2\n        for ent in os.listdir(base_dir):\n            if len(ent) == digest_size:\n                self._store_image(base_dir, ent, original=True)\n\nand it's only the base disk images which are stored using their sha1 sum as their filename:\n\n        if disk_images['kernel_id']:\n            fname = disk_images['kernel_id']\n            raw('kernel').cache(fetch_func=libvirt_utils.fetch_image,\n                                context=context,\n                                filename=fname,\n                                ...)\n            if disk_images['ramdisk_id']:\n                fname = disk_images['ramdisk_id']\n                raw('ramdisk').cache(fetch_func=libvirt_utils.fetch_image,\n                                     context=context,\n                                     filename=fname,\n                                     ...)\n\n        root_fname = hashlib.sha1(str(disk_images['image_id'])).hexdigest()\n        ...\n        if 'disk' in disk_mapping:\n            image('disk').cache(fetch_func=libvirt_utils.fetch_image,\n                                context=context,\n                                filename=root_fname,\n                                ...)\n\nAssuming I'm not missing something and it does make sense to clean these up, I guess we can:\n\n  1) start storing kernels and ramdisks using their sha1 sum as their filename or\n\n  2) have the image cache manager somehow recognize the kernel/ramdisk filenames as images to examine\n\nWe also need the image cache manager to track kernels and ramdisks as used images when listing instances\n\ni.e. need to include kernel_id and ramdisk_id here:\n\n            image_ref_str = str(instance['image_ref'])\n            local, remote, insts = self.used_images.get(image_ref_str,\n                                                        (0, 0, []))", 
            "date_created": "2013-02-23 15:25:04.837029+00:00", 
            "author": "https://api.launchpad.net/1.0/~markmc"
        }, 
        {
            "content": "Fix proposed to branch: master\nReview: https://review.openstack.org/22777", 
            "date_created": "2013-02-23 16:04:21.204653+00:00", 
            "author": "https://api.launchpad.net/1.0/~hudson-openstack"
        }, 
        {
            "content": "Reviewed:  https://review.openstack.org/22777\nCommitted: http://github.com/openstack/nova/commit/38997fc916904e47dcb847e1737eb26cbd38f6e1\nSubmitter: Jenkins\nBranch:    master\n\ncommit 38997fc916904e47dcb847e1737eb26cbd38f6e1\nAuthor: Mark McLoughlin <email address hidden>\nDate:   Sat Feb 23 15:24:20 2013 +0000\n\n    Clean unused kernels and ramdisks from image cache\n    \n    Fixes bug #1132138\n    \n    Only unused disk images are currently cleaned up by the image cache\n    manager but it seems logical to clean up unused kernels and ramdisks\n    too.\n    \n    Achieve that by writing kernels and ramdisks to disk using the sha1\n    sum of their ID as the filename. This is the same scheme as used for\n    disk image filenames and causes the image cache manager to consider\n    them for cleanup. We also make the cache manager take note of in use\n    kernels and ramdisks when iterating over the list of instances.\n    \n    A nasty upgrade concern is that if we immediately switch to writing\n    kernels to disk using this scheme then, where shared storage is used,\n    we can have older image cache managers on remote compute nodes cleaning\n    up kernels because they appear unused. To mitigate that, turn off this\n    behaviour by default and allow it to be enabled using a new config\n    option. This option will be removed in future and the behaviour enabled\n    by default.\n    \n    DocImpact: new remove_unused_kernels option\n    \n    Change-Id: I56bba9fa6596601104498e262c2e657f0eae2fa0\n", 
            "date_created": "2013-02-25 16:09:38.927963+00:00", 
            "author": "https://api.launchpad.net/1.0/~hudson-openstack"
        }
    ]
}